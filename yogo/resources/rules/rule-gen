(ns gen-rules)

(defrule identuneq
  (no-root)
  (ident <- (generic/ident _))
  =>
  (s/insert-ineclass ident 'ident-ineclass))

;; -----
;; Assignment
;; -----

(defrule assignment-r-v
  (generic/val (generic/assign _ _ rvalue))
  =>
  rvalue)

(defrule assignment-v-q
  (engine/q
   (generic/mem (generic/assign _ lvalue rvalue))
   lvalue)
  =>
  rvalue)

(defrule assignment-qs
  (engine/q (mem <- (generic/mem (generic/assign mem-in lvalue1 _))) lvalue2)
  (un-eq lvalue1 lvalue2)
  =>
  (engine/q mem-in lvalue2))

;; -----
;; Cond
;; -----

(defrule cond-q
  "Q(cond(p, mem-t, mem-f), id) = cond(p, Q(mem-t, id), Q(mem-f, id))"
  (q <- (engine/q (generic/cond p mem-t mem-f) id))
  =>
  (generic/cond p (engine/q mem-t id) (engine/q mem-f id)))

(defrule cond-negate
  "cond(not(p), t, f) == cond(p, f, t)"
  (generic/cond (generic/unop :not p) t f)
  =>
  (generic/cond p f t))

(defrule cond-eq
  "cond(p, x, x) = x"
  (generic/cond _ x x)
  =>
  x)

;; ----------
;; Loops
;; ----------

(defrule make-loop
  (engine/q (mem-loop <- (generic/loop depth init next)) lvalue)
  =>
  (generic/loop depth (engine/q init lvalue) (engine/q next lvalue)))

(defrule make-final
  "Q(final(loop, depth), lvalue) = final(Q(loop, lvalue), depth)"
  (engine/q (generic/final depth cond loop) lvalue)
  =>
  (generic/final depth cond (engine/q loop lvalue)))

(defrule join-qs-loop
  (q-loop <- (engine/q (generic/loop _ init next) lvalue))
  (q-loop <- (engine/q next lvalue))
  =>
  (engine/q init lvalue))

(defrule join-qs-final
  (q-loop <- (engine/q (loop <- (generic/loop depth init _) lvalue)))
  (q-loop <- (engine/q init lvalue))
  (final <- (generic/final depth loop _))
  =>
  (engine/q final lvalue))

;; ----------
;; Boolean
;; ----------

(defrule double-negation
  "not(not(p)) == p"
  (generic/unop :not (generic/unop :not p))
  =>
  p)

;; -----
;; Arithmetics
;; -----

(defrule addition-commutative
  "(+ a b) = (+ b a)"
  (generic/binop :+ a b)
  =>
  (generic/binop :+ b a))

(defrule multiplication-commutative
  "(* a b) = (* b a)"
  (generic/binop :* a b)
  =>
  (generic/binop :* b a))

(defrule mult-add-distributive
  "a * (b + c) = (a * b) + (a * c)"
  (generic/binop :* a (generic/binop :+ b c))
  =>
  (generic/binop :+
                  (generic/binop :* a b)
                  (generic/binop :* a c)))

;; -----
;; Concepts
;; -----

(defrule fcall-name
  (generic/fcall mem (engine/q _ (generic/ident name)) fargs)
  =>
  (concept/fcall-name mem name fargs))

(defrule sqrt
  (generic/val (concept/fcall-name _ "sqrt" (generic/fargs x (generic/nothing))))
  =>
  (concept/sqrt x))

(defrule x-or-y-value
  "cond(x, x, y) = x-or-y-value(x, y)"
  (generic/cond x x y)
  =>
  (concept/x-or-y-value x y))

(defrule loop-num-seq
  (i <- (generic/loop depth init (generic/binop :+ i k)))
  (invariant k depth)
  =>
  (generic/iter-v depth (concept/seq init k)))

;; (defrule len-obj-size
;;   "val(fcall-name(mem, 'len', [m])) == size(Q(mem, at(m)))"
;;   (generic/val (concept/fcall-name mem "len" (generic/fargs m (generic/nothing))))
;;   =>
;;   (concept/size (engine/q mem (generic/at m))))

;; (defrule m-get
;;   "Q(mem, sel(m, k)) = get(Q(mem, at(m)), k)"
;;   ;; Once m is defined, it's at-Q always returns a object.
;;   (engine/q mem (generic/sel m k))
;;   =>
;;   (concept/get (engine/q mem (generic/at m)) k))

(defrule seq-range-iter-v
  (generic/iter-v d (concept/range i n k))
  =>
  (println "iter-v" i k)
  (generic/iter-v d (concept/seq i k)))

(defrule seq-range-iter-p
  (generic/iter-p d (concept/range i n k))
  =>
  (generic/binop :< (generic/iter-v d (concept/seq i k)) n))

(defrule seq-n+1
  (generic/binop
   :<
   (seq <- (generic/iter-v d (concept/seq i k)))
   (generic/binop :+ n k))
  (invariant n d)
  =>
  (generic/binop :<= seq n))
