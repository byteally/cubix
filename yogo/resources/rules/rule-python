(ns python-rule)

(defrule assign-pylhs
  "Unroll complex assignment into two assignments"
  (generic/assign mem-in (python/lhs lvalue1 lvalue2) rvalue)
  =>
  (generic/assign (generic/mem (generic/assign mem-in lvalue2 rvalue)) lvalue1 rvalue))

(defrule fn-pure
  (mem-out <- (generic/mem (concept/fcall-name mem-in name _)))
  =>
  (if (#{} name) mem-in mem-out))

(defrule fn-readonly
  (q-after <- (engine/q (generic/mem (concept/fcall-name mem-in name _)) lvalue))
  (q-before <- (engine/q mem-in lvalue))
  =>
  (if (#{"input", "print"} name) q-before q-after))

(defrule assignment-qs-stack-heap
  (engine/q (mem <- (generic/mem (generic/assign mem-in lvalue1 _))) lvalue2)
  (lvalue1 <- (generic/any-stack-lvalue))
  (lvalue2 <- (generic/any-heap-lvalue))
  =>
  (engine/q mem-in lvalue2))

(defrule assignment-qs-heap-stack
  (engine/q (mem <- (generic/mem (generic/assign mem-in lvalue1 _))) lvalue2)
  (lvalue1 <- (generic/any-heap-lvalue))
  (lvalue2 <- (generic/any-stack-lvalue))
  =>
  (engine/q mem-in lvalue2))

;; Maybe make membership a memory operation?
(defrule membership-1
  (generic/binop :py-in k m)
  =>
  (concept/membership m k))

(defrule membership-2
  (generic/binop :py-not-in k m)
  =>
  (generic/unop
   :not
   (concept/membership m k)))
