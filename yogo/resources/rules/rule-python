(ns python-rule)

(defrule assign-pylhs
  "Unroll complex assignment into two assignments"
  (generic/assign mem-in (python/lhs lvalue1 lvalue2) rvalue)
  =>
  (generic/assign (generic/mem (generic/assign mem-in lvalue2 rvalue)) lvalue1 rvalue))

(defrule fn-pure
  (mem-out <- (generic/mem (concept/fcall-name mem-in name _)))
  =>
  (if (#{"range", "enumerate"} name) mem-in mem-out))

(defrule fn-readonly
  (q-after <- (engine/q (generic/mem (concept/fcall-name mem-in name _)) lvalue))
  (q-before <- (engine/q mem-in lvalue))
  =>
  (if (#{"input", "print"} name) q-before q-after))

(defrule assignment-qs-stack-heap
  (engine/q (mem <- (generic/mem (generic/assign mem-in lvalue1 _))) lvalue2)
  (lvalue1 <- (generic/any-stack-lvalue))
  (lvalue2 <- (generic/any-heap-lvalue))
  =>
  (engine/q mem-in lvalue2))

(defrule assignment-qs-heap-stack
  (engine/q (mem <- (generic/mem (generic/assign mem-in lvalue1 _))) lvalue2)
  (lvalue1 <- (generic/any-heap-lvalue))
  (lvalue2 <- (generic/any-stack-lvalue))
  =>
  (engine/q mem-in lvalue2))

;; Maybe make membership a memory operation?
(defrule membership-1
  (generic/binop :py-in k m)
  =>
  (concept/membership m k))

(defrule membership-2
  (generic/binop :py-not-in k m)
  =>
  (generic/unop
   :not
   (concept/membership m k)))

(defrule range-1
  (generic/val (concept/fcall-name _ "range" fargs))
  (fargs <- (generic/fargs n (generic/nothing)))
  =>
  (println "range-1")
  (concept/range (generic/const 0) n (generic/const 1)))

(defrule range-2
  (generic/val (concept/fcall-name _ "range" fargs))
  (fargs <- (generic/fargs i (generic/fargs n (generic/nothing))))
  =>
  (println "range-2")
  (concept/range i n (generic/const 1)))

(defrule range-3
  (generic/val (concept/fcall-name _ "range" fargs))
  (fargs <- (generic/fargs i (generic/fargs n (generic/fargs k (generic/nothing)))))
  =>
  (concept/range i n k))

(defrule enumerate
  (generic/mem
   (generic/assign mem
                   (python/list-lv a1 a2)
                   (generic/iter-v d (generic/val
                                      (concept/fcall-name _ "enumerate"
                                                          (generic/fargs l (generic/nothing)))))))
  =>
  (println "yp")
  (generic/mem
   (generic/assign
    (generic/mem
     (generic/assign
      mem a1 (generic/iter-v d (concept/seq (generic/const 0) (generic/const 1)))))
    a2 (generic/iter-v d l))))
